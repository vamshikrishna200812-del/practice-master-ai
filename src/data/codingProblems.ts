export interface TestCase {
  input: string;
  expectedOutput: string;
  hidden?: boolean;
}

export interface CodingProblem {
  id: string;
  title: string;
  slug: string;
  difficulty: "Easy" | "Medium" | "Hard";
  category: string;
  tags: string[];
  description: string;
  inputFormat: string;
  outputFormat: string;
  constraints: string[];
  sampleCases: { input: string; output: string; explanation?: string }[];
  testCases: TestCase[];
  starterCode: Record<string, string>;
  editorial?: string;
  hints: string[];
  points?: number;
}

export interface CodingCourse {
  id: string;
  title: string;
  description: string;
  icon: string;
  problemIds: string[];
}

// Helper to generate minimal starter code for all 5 languages
const makeStarter = (opts: {
  jsSetup: string;
  pySetup: string;
  javaSetup: string;
  cppSetup: string;
  cSetup: string;
}): Record<string, string> => ({
  javascript: opts.jsSetup,
  python: opts.pySetup,
  java: opts.javaSetup,
  cpp: opts.cppSetup,
  c: opts.cSetup,
});

const simpleStarter = (name: string) => makeStarter({
  jsSetup: `const n = parseInt(input.trim());\n// Write your solution for ${name} here\n`,
  pySetup: `n = int(input_data.strip())\n# Write your solution for ${name} here\n`,
  javaSetup: `import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // Write your solution for ${name} here\n    }\n}`,
  cppSetup: `#include <iostream>\nusing namespace std;\n\nint main() {\n    // Write your solution for ${name} here\n    return 0;\n}`,
  cSetup: `#include <stdio.h>\n\nint main() {\n    // Write your solution for ${name} here\n    return 0;\n}`,
});

const arrayStarter = (name: string) => makeStarter({
  jsSetup: `const nums = input.trim().split(" ").map(Number);\n// ${name}\n`,
  pySetup: `nums = list(map(int, input_data.strip().split()))\n# ${name}\n`,
  javaSetup: `import java.util.*;\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] p = sc.nextLine().split(" ");\n        int[] nums = new int[p.length];\n        for(int i=0;i<p.length;i++) nums[i]=Integer.parseInt(p[i]);\n        // ${name}\n    }\n}`,
  cppSetup: `#include <iostream>\n#include <vector>\n#include <sstream>\nusing namespace std;\nint main() {\n    string line; getline(cin,line);\n    istringstream iss(line); vector<int> nums; int n;\n    while(iss>>n) nums.push_back(n);\n    // ${name}\n    return 0;\n}`,
  cSetup: `#include <stdio.h>\nint main() {\n    int nums[100000], n=0, x;\n    while(scanf("%d",&x)==1) nums[n++]=x;\n    // ${name}\n    return 0;\n}`,
});

const stringStarter = (name: string) => makeStarter({
  jsSetup: `const s = input.trim();\n// ${name}\n`,
  pySetup: `s = input_data.strip()\n# ${name}\n`,
  javaSetup: `import java.util.*;\npublic class Solution {\n    public static void main(String[] args) {\n        String s = new Scanner(System.in).nextLine();\n        // ${name}\n    }\n}`,
  cppSetup: `#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n    string s; getline(cin,s);\n    // ${name}\n    return 0;\n}`,
  cSetup: `#include <stdio.h>\n#include <string.h>\nint main() {\n    char s[100001]; fgets(s,sizeof(s),stdin); s[strcspn(s,"\\n")]=0;\n    // ${name}\n    return 0;\n}`,
});

const twoLineStarter = (name: string) => makeStarter({
  jsSetup: `const lines = input.trim().split("\\n");\n// ${name}\n`,
  pySetup: `lines = input_data.strip().split("\\n")\n# ${name}\n`,
  javaSetup: `import java.util.*;\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // ${name}\n    }\n}`,
  cppSetup: `#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    // ${name}\n    return 0;\n}`,
  cSetup: `#include <stdio.h>\nint main() {\n    // ${name}\n    return 0;\n}`,
});

export const codingProblems: CodingProblem[] = [
  // ===== EASY (1-18) =====
  {
    id: "two-sum", title: "Two Sum", slug: "two-sum", difficulty: "Easy", category: "Arrays",
    tags: ["arrays", "hash-map"], points: 10,
    description: "Given an array of integers `nums` and an integer `target`, return the **indices** of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.",
    inputFormat: "First line: space-separated integers (the array)\nSecond line: an integer (the target)",
    outputFormat: "Two space-separated integers representing the indices (0-indexed).",
    constraints: ["2 ≤ nums.length ≤ 10⁴", "-10⁹ ≤ nums[i] ≤ 10⁹", "Only one valid answer exists."],
    sampleCases: [{ input: "2 7 11 15\n9", output: "0 1", explanation: "nums[0] + nums[1] = 2 + 7 = 9" }, { input: "3 2 4\n6", output: "1 2" }],
    testCases: [{ input: "2 7 11 15\n9", expectedOutput: "0 1" }, { input: "3 2 4\n6", expectedOutput: "1 2" }, { input: "3 3\n6", expectedOutput: "0 1" }, { input: "1 5 3 7 2\n9", expectedOutput: "1 3", hidden: true }, { input: "-1 -2 -3 -4 -5\n-8", expectedOutput: "2 4", hidden: true }],
    starterCode: twoLineStarter("Two Sum"),
    hints: ["A brute-force approach would check every pair — O(n²).", "Can you use a hash map to bring it to O(n)?"],
    editorial: "Use a hash map to store each number's index as you iterate. For each element, check if `target - nums[i]` already exists in the map. Time: O(n), Space: O(n).",
  },
  {
    id: "reverse-string", title: "Reverse String", slug: "reverse-string", difficulty: "Easy", category: "Strings",
    tags: ["strings", "two-pointers"], points: 10,
    description: "Write a function that reverses a string. The input string is given as a single line.",
    inputFormat: "A single line containing a string.", outputFormat: "The reversed string.",
    constraints: ["1 ≤ s.length ≤ 10⁵"],
    sampleCases: [{ input: "hello", output: "olleh" }, { input: "Hannah", output: "hannaH" }],
    testCases: [{ input: "hello", expectedOutput: "olleh" }, { input: "Hannah", expectedOutput: "hannaH" }, { input: "a", expectedOutput: "a" }, { input: "racecar", expectedOutput: "racecar", hidden: true }],
    starterCode: stringStarter("Reverse String"), hints: ["Use two pointers."], editorial: "Swap characters from both ends. O(n).",
  },
  {
    id: "fizzbuzz", title: "FizzBuzz", slug: "fizzbuzz", difficulty: "Easy", category: "Basics",
    tags: ["loops", "conditionals"], points: 10,
    description: 'Given an integer `n`, print numbers from 1 to `n`. For multiples of 3 print `"Fizz"`, for 5 print `"Buzz"`, for both print `"FizzBuzz"`.',
    inputFormat: "A single integer n.", outputFormat: "n lines of output.",
    constraints: ["1 ≤ n ≤ 10⁵"],
    sampleCases: [{ input: "5", output: "1\n2\nFizz\n4\nBuzz" }],
    testCases: [{ input: "5", expectedOutput: "1\n2\nFizz\n4\nBuzz" }, { input: "15", expectedOutput: "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz" }, { input: "3", expectedOutput: "1\n2\nFizz", hidden: true }],
    starterCode: simpleStarter("FizzBuzz"), hints: ["Check divisibility by 15 first."], editorial: "Loop 1 to n, check i%15, i%3, i%5.",
  },
  {
    id: "palindrome-check", title: "Palindrome Check", slug: "palindrome-check", difficulty: "Easy", category: "Strings",
    tags: ["strings", "two-pointers"], points: 10,
    description: "Given a string `s`, determine if it's a palindrome considering only alphanumeric characters. Print `true` or `false`.",
    inputFormat: "A single line string.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ s.length ≤ 2 × 10⁵"],
    sampleCases: [{ input: "A man, a plan, a canal: Panama", output: "true" }, { input: "race a car", output: "false" }],
    testCases: [{ input: "A man, a plan, a canal: Panama", expectedOutput: "true" }, { input: "race a car", expectedOutput: "false" }, { input: " ", expectedOutput: "true" }, { input: "hello", expectedOutput: "false", hidden: true }],
    starterCode: stringStarter("Palindrome Check"), hints: ["Filter non-alphanumeric, lowercase, then two pointers."], editorial: "O(n) with two pointers.",
  },
  {
    id: "valid-parentheses", title: "Valid Parentheses", slug: "valid-parentheses", difficulty: "Easy", category: "Stacks",
    tags: ["stacks", "strings"], points: 10,
    description: "Given a string containing just `()[]{}`, determine if the input string is valid.",
    inputFormat: "A single line of brackets.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ s.length ≤ 10⁴"],
    sampleCases: [{ input: "()", output: "true" }, { input: "(]", output: "false" }],
    testCases: [{ input: "()", expectedOutput: "true" }, { input: "()[]{}", expectedOutput: "true" }, { input: "(]", expectedOutput: "false" }, { input: "{[]}", expectedOutput: "true", hidden: true }],
    starterCode: stringStarter("Valid Parentheses"), hints: ["Use a stack."], editorial: "Push opening brackets, pop on closing. O(n).",
  },
  {
    id: "binary-search", title: "Binary Search", slug: "binary-search", difficulty: "Easy", category: "Searching",
    tags: ["binary-search", "arrays"], points: 10,
    description: "Given a sorted array and a target, return the index of target or -1.",
    inputFormat: "First line: sorted array\nSecond line: target", outputFormat: "Index or -1.",
    constraints: ["1 ≤ nums.length ≤ 10⁴"],
    sampleCases: [{ input: "-1 0 3 5 9 12\n9", output: "4" }],
    testCases: [{ input: "-1 0 3 5 9 12\n9", expectedOutput: "4" }, { input: "-1 0 3 5 9 12\n2", expectedOutput: "-1" }, { input: "5\n5", expectedOutput: "0" }, { input: "1 2 3 4 5 6 7 8 9 10\n10", expectedOutput: "9", hidden: true }],
    starterCode: twoLineStarter("Binary Search"), hints: ["Two pointers: left and right."], editorial: "Classic binary search. O(log n).",
  },
  {
    id: "merge-sorted-arrays", title: "Merge Two Sorted Arrays", slug: "merge-sorted-arrays", difficulty: "Easy", category: "Arrays",
    tags: ["arrays", "two-pointers", "sorting"], points: 10,
    description: "Given two sorted arrays, merge them into a single sorted array.",
    inputFormat: "Two lines of space-separated integers.", outputFormat: "Space-separated sorted integers.",
    constraints: ["0 ≤ length ≤ 10⁴"],
    sampleCases: [{ input: "1 2 4\n1 3 4", output: "1 1 2 3 4 4" }],
    testCases: [{ input: "1 2 4\n1 3 4", expectedOutput: "1 1 2 3 4 4" }, { input: "1\n0", expectedOutput: "0 1" }, { input: "1 3 5 7\n2 4 6 8", expectedOutput: "1 2 3 4 5 6 7 8", hidden: true }],
    starterCode: twoLineStarter("Merge Sorted Arrays"), hints: ["Two-pointer technique."], editorial: "Two pointers, compare heads. O(n+m).",
  },
  {
    id: "climbing-stairs", title: "Climbing Stairs", slug: "climbing-stairs", difficulty: "Easy", category: "Dynamic Programming",
    tags: ["dynamic-programming", "math"], points: 10,
    description: "It takes `n` steps to reach the top. Each time you can climb 1 or 2 steps. How many distinct ways?",
    inputFormat: "A single integer n.", outputFormat: "Number of ways.",
    constraints: ["1 ≤ n ≤ 45"],
    sampleCases: [{ input: "2", output: "2" }, { input: "3", output: "3" }],
    testCases: [{ input: "2", expectedOutput: "2" }, { input: "3", expectedOutput: "3" }, { input: "1", expectedOutput: "1" }, { input: "10", expectedOutput: "89", hidden: true }],
    starterCode: simpleStarter("Climbing Stairs"), hints: ["This is Fibonacci."], editorial: "dp[i] = dp[i-1] + dp[i-2]. O(n).",
  },
  {
    id: "single-number", title: "Single Number", slug: "single-number", difficulty: "Easy", category: "Bit Manipulation",
    tags: ["bit-manipulation", "arrays"], points: 10,
    description: "Given a non-empty array where every element appears twice except one, find that single one.",
    inputFormat: "Space-separated integers.", outputFormat: "The single number.",
    constraints: ["1 ≤ nums.length ≤ 3 × 10⁴"],
    sampleCases: [{ input: "2 2 1", output: "1" }, { input: "4 1 2 1 2", output: "4" }],
    testCases: [{ input: "2 2 1", expectedOutput: "1" }, { input: "4 1 2 1 2", expectedOutput: "4" }, { input: "1", expectedOutput: "1" }, { input: "7 3 5 3 5", expectedOutput: "7", hidden: true }],
    starterCode: arrayStarter("Single Number"), hints: ["XOR all numbers together."], editorial: "XOR: a ^ a = 0. XOR all gives the single number. O(n).",
  },
  {
    id: "max-depth-bt", title: "Maximum Depth of Binary Tree", slug: "max-depth-bt", difficulty: "Easy", category: "Trees",
    tags: ["trees", "recursion", "dfs"], points: 10,
    description: "Given a binary tree as level-order array (with -1 for null), find its maximum depth.",
    inputFormat: "Space-separated integers (-1 = null).", outputFormat: "The max depth.",
    constraints: ["0 ≤ nodes ≤ 10⁴"],
    sampleCases: [{ input: "3 9 20 -1 -1 15 7", output: "3" }, { input: "1 -1 2", output: "2" }],
    testCases: [{ input: "3 9 20 -1 -1 15 7", expectedOutput: "3" }, { input: "1 -1 2", expectedOutput: "2" }, { input: "1", expectedOutput: "1" }, { input: "1 2 3 4 5 -1 -1 6", expectedOutput: "4", hidden: true }],
    starterCode: arrayStarter("Max Depth of Binary Tree"), hints: ["Use recursive DFS."], editorial: "Recursively find depth of left/right subtree, return max + 1. O(n).",
  },
  {
    id: "invert-binary-tree", title: "Invert Binary Tree", slug: "invert-binary-tree", difficulty: "Easy", category: "Trees",
    tags: ["trees", "recursion"], points: 10,
    description: "Given a binary tree as level-order array, invert it and print the level-order result.",
    inputFormat: "Space-separated integers (-1 = null).", outputFormat: "Level-order of inverted tree.",
    constraints: ["0 ≤ nodes ≤ 100"],
    sampleCases: [{ input: "4 2 7 1 3 6 9", output: "4 7 2 9 6 3 1" }],
    testCases: [{ input: "4 2 7 1 3 6 9", expectedOutput: "4 7 2 9 6 3 1" }, { input: "2 1 3", expectedOutput: "2 3 1" }, { input: "1", expectedOutput: "1", hidden: true }],
    starterCode: arrayStarter("Invert Binary Tree"), hints: ["Swap left and right children recursively."], editorial: "Recursive: swap children at each node. O(n).",
  },
  {
    id: "linked-list-reverse", title: "Reverse Linked List", slug: "reverse-linked-list", difficulty: "Easy", category: "Linked Lists",
    tags: ["linked-lists"], points: 10,
    description: "Given a linked list as space-separated values, reverse it and print the result.",
    inputFormat: "Space-separated integers.", outputFormat: "Reversed list.",
    constraints: ["0 ≤ length ≤ 5000"],
    sampleCases: [{ input: "1 2 3 4 5", output: "5 4 3 2 1" }],
    testCases: [{ input: "1 2 3 4 5", expectedOutput: "5 4 3 2 1" }, { input: "1 2", expectedOutput: "2 1" }, { input: "1", expectedOutput: "1", hidden: true }],
    starterCode: arrayStarter("Reverse Linked List"), hints: ["Use three pointers: prev, curr, next."], editorial: "Iterative: prev=null, curr=head, swap pointers. O(n).",
  },
  {
    id: "contains-duplicate", title: "Contains Duplicate", slug: "contains-duplicate", difficulty: "Easy", category: "Arrays",
    tags: ["arrays", "hash-map"], points: 10,
    description: "Given an integer array, return `true` if any value appears at least twice, `false` if every element is distinct.",
    inputFormat: "Space-separated integers.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ nums.length ≤ 10⁵"],
    sampleCases: [{ input: "1 2 3 1", output: "true" }, { input: "1 2 3 4", output: "false" }],
    testCases: [{ input: "1 2 3 1", expectedOutput: "true" }, { input: "1 2 3 4", expectedOutput: "false" }, { input: "1 1 1 3 3 4 3 2 4 2", expectedOutput: "true", hidden: true }],
    starterCode: arrayStarter("Contains Duplicate"), hints: ["Use a hash set."], editorial: "Add to set, check if already present. O(n).",
  },
  {
    id: "counting-sort", title: "Counting Sort", slug: "counting-sort", difficulty: "Easy", category: "Sorting",
    tags: ["sorting", "arrays"], points: 10,
    description: "Sort an array of non-negative integers using counting sort.",
    inputFormat: "Space-separated non-negative integers.", outputFormat: "Sorted integers.",
    constraints: ["1 ≤ n ≤ 10⁵", "0 ≤ nums[i] ≤ 1000"],
    sampleCases: [{ input: "4 2 2 8 3 3 1", output: "1 2 2 3 3 4 8" }],
    testCases: [{ input: "4 2 2 8 3 3 1", expectedOutput: "1 2 2 3 3 4 8" }, { input: "1", expectedOutput: "1" }, { input: "5 3 1 4 2", expectedOutput: "1 2 3 4 5", hidden: true }],
    starterCode: arrayStarter("Counting Sort"), hints: ["Count frequency of each value."], editorial: "Count occurrences, reconstruct array. O(n+k).",
  },
  {
    id: "valid-anagram", title: "Valid Anagram", slug: "valid-anagram", difficulty: "Easy", category: "Strings",
    tags: ["strings", "hash-map", "sorting"], points: 10,
    description: "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, `false` otherwise.",
    inputFormat: "Two lines, each a string.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ s.length, t.length ≤ 5 × 10⁴"],
    sampleCases: [{ input: "anagram\nnagaram", output: "true" }, { input: "rat\ncar", output: "false" }],
    testCases: [{ input: "anagram\nnagaram", expectedOutput: "true" }, { input: "rat\ncar", expectedOutput: "false" }, { input: "a\nab", expectedOutput: "false", hidden: true }],
    starterCode: twoLineStarter("Valid Anagram"), hints: ["Count character frequencies."], editorial: "Frequency count with hash map. O(n).",
  },
  {
    id: "move-zeroes", title: "Move Zeroes", slug: "move-zeroes", difficulty: "Easy", category: "Arrays",
    tags: ["arrays", "two-pointers"], points: 10,
    description: "Given an array, move all 0's to the end while maintaining relative order of non-zero elements.",
    inputFormat: "Space-separated integers.", outputFormat: "Array with zeroes moved to end.",
    constraints: ["1 ≤ nums.length ≤ 10⁴"],
    sampleCases: [{ input: "0 1 0 3 12", output: "1 3 12 0 0" }],
    testCases: [{ input: "0 1 0 3 12", expectedOutput: "1 3 12 0 0" }, { input: "0", expectedOutput: "0" }, { input: "1 2 3", expectedOutput: "1 2 3", hidden: true }],
    starterCode: arrayStarter("Move Zeroes"), hints: ["Use a write pointer for non-zero values."], editorial: "Two-pointer: write pointer fills non-zeroes, pad rest. O(n).",
  },
  {
    id: "symmetric-tree", title: "Symmetric Tree", slug: "symmetric-tree", difficulty: "Easy", category: "Trees",
    tags: ["trees", "recursion", "bfs"], points: 10,
    description: "Check whether a binary tree (given as level-order, -1=null) is a mirror of itself.",
    inputFormat: "Space-separated integers.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ nodes ≤ 1000"],
    sampleCases: [{ input: "1 2 2 3 4 4 3", output: "true" }, { input: "1 2 2 -1 3 -1 3", output: "false" }],
    testCases: [{ input: "1 2 2 3 4 4 3", expectedOutput: "true" }, { input: "1 2 2 -1 3 -1 3", expectedOutput: "false" }, { input: "1", expectedOutput: "true", hidden: true }],
    starterCode: arrayStarter("Symmetric Tree"), hints: ["Compare left subtree with mirror of right."], editorial: "Recursive comparison of mirror nodes. O(n).",
  },
  {
    id: "best-time-buy-sell", title: "Best Time to Buy and Sell Stock", slug: "best-time-buy-sell", difficulty: "Easy", category: "Arrays",
    tags: ["arrays", "greedy", "dynamic-programming"], points: 10,
    description: "Given an array `prices`, find the max profit from one buy/sell. Return 0 if no profit possible.",
    inputFormat: "Space-separated integers (prices).", outputFormat: "Max profit.",
    constraints: ["1 ≤ prices.length ≤ 10⁵"],
    sampleCases: [{ input: "7 1 5 3 6 4", output: "5" }, { input: "7 6 4 3 1", output: "0" }],
    testCases: [{ input: "7 1 5 3 6 4", expectedOutput: "5" }, { input: "7 6 4 3 1", expectedOutput: "0" }, { input: "2 4 1", expectedOutput: "2", hidden: true }],
    starterCode: arrayStarter("Best Time to Buy and Sell Stock"), hints: ["Track minimum price so far."], editorial: "Track min price, compute max profit at each step. O(n).",
  },

  // ===== MEDIUM (19-40) =====
  {
    id: "max-subarray", title: "Maximum Subarray", slug: "maximum-subarray", difficulty: "Medium", category: "Arrays",
    tags: ["arrays", "dynamic-programming", "greedy"], points: 20,
    description: "Given an integer array, find the subarray with the largest sum.",
    inputFormat: "Space-separated integers.", outputFormat: "The maximum subarray sum.",
    constraints: ["1 ≤ nums.length ≤ 10⁵"],
    sampleCases: [{ input: "-2 1 -3 4 -1 2 1 -5 4", output: "6", explanation: "[4,-1,2,1] has sum 6." }],
    testCases: [{ input: "-2 1 -3 4 -1 2 1 -5 4", expectedOutput: "6" }, { input: "1", expectedOutput: "1" }, { input: "-1", expectedOutput: "-1", hidden: true }],
    starterCode: arrayStarter("Maximum Subarray"), hints: ["Kadane's algorithm."], editorial: "Kadane's: currentSum = max(num, currentSum+num). O(n).",
  },
  {
    id: "longest-substring", title: "Longest Substring Without Repeating Characters", slug: "longest-substring", difficulty: "Medium", category: "Strings",
    tags: ["strings", "sliding-window", "hash-map"], points: 20,
    description: "Find the length of the longest substring without repeating characters.",
    inputFormat: "A single string.", outputFormat: "An integer.",
    constraints: ["0 ≤ s.length ≤ 5 × 10⁴"],
    sampleCases: [{ input: "abcabcbb", output: "3" }, { input: "bbbbb", output: "1" }],
    testCases: [{ input: "abcabcbb", expectedOutput: "3" }, { input: "bbbbb", expectedOutput: "1" }, { input: "pwwkew", expectedOutput: "3" }, { input: "dvdf", expectedOutput: "3", hidden: true }],
    starterCode: stringStarter("Longest Substring"), hints: ["Sliding window with hash set."], editorial: "Expand right, shrink left on duplicates. O(n).",
  },
  {
    id: "linked-list-cycle", title: "Detect Cycle in Linked List", slug: "linked-list-cycle", difficulty: "Medium", category: "Linked Lists",
    tags: ["linked-lists", "two-pointers"], points: 20,
    description: "Given linked list values and a pos (-1 for no cycle), determine if there's a cycle. Print `true` or `false`.",
    inputFormat: "First line: values. Second line: pos.", outputFormat: "`true` or `false`",
    constraints: ["0 ≤ length ≤ 10⁴"],
    sampleCases: [{ input: "3 2 0 -4\n1", output: "true" }],
    testCases: [{ input: "3 2 0 -4\n1", expectedOutput: "true" }, { input: "1 2\n0", expectedOutput: "true" }, { input: "1\n-1", expectedOutput: "false" }, { input: "1 2 3 4 5\n-1", expectedOutput: "false", hidden: true }],
    starterCode: twoLineStarter("Linked List Cycle"), hints: ["Floyd's Tortoise and Hare."], editorial: "Slow/fast pointers. O(n) time, O(1) space.",
  },
  {
    id: "sort-array", title: "Sort an Array", slug: "sort-array", difficulty: "Medium", category: "Sorting",
    tags: ["sorting", "divide-and-conquer"], points: 20,
    description: "Sort an array without using built-in sort.",
    inputFormat: "Space-separated integers.", outputFormat: "Sorted space-separated integers.",
    constraints: ["1 ≤ nums.length ≤ 5 × 10⁴"],
    sampleCases: [{ input: "5 2 3 1", output: "1 2 3 5" }],
    testCases: [{ input: "5 2 3 1", expectedOutput: "1 2 3 5" }, { input: "5 1 1 2 0 0", expectedOutput: "0 0 1 1 2 5" }, { input: "3 -1 0 2 -5", expectedOutput: "-5 -1 0 2 3", hidden: true }],
    starterCode: arrayStarter("Sort Array"), hints: ["Merge sort guarantees O(n log n)."], editorial: "Merge sort: divide, sort halves, merge.",
  },
  {
    id: "coin-change", title: "Coin Change", slug: "coin-change", difficulty: "Medium", category: "Dynamic Programming",
    tags: ["dynamic-programming", "greedy"], points: 20,
    description: "Given coins of different denominations and a total amount, return the fewest number of coins needed. Return -1 if impossible.",
    inputFormat: "First line: space-separated coin values.\nSecond line: amount.", outputFormat: "Min coins or -1.",
    constraints: ["1 ≤ coins.length ≤ 12", "1 ≤ coins[i] ≤ 2³¹-1", "0 ≤ amount ≤ 10⁴"],
    sampleCases: [{ input: "1 5 10\n11", output: "3", explanation: "10+1 = 11 (2 coins) — wait, 5+5+1=11 (3 coins). Actually 10+1=11 needs 2. Let me fix: 11 = 10+1 = 2 coins" }],
    testCases: [{ input: "1 5 10\n11", expectedOutput: "2" }, { input: "2\n3", expectedOutput: "-1" }, { input: "1\n0", expectedOutput: "0" }, { input: "1 2 5\n11", expectedOutput: "3", hidden: true }],
    starterCode: twoLineStarter("Coin Change"), hints: ["dp[i] = min coins to make amount i."], editorial: "Bottom-up DP: dp[i] = min(dp[i-c]+1) for each coin c. O(amount × coins).",
  },
  {
    id: "longest-common-subseq", title: "Longest Common Subsequence", slug: "longest-common-subsequence", difficulty: "Medium", category: "Dynamic Programming",
    tags: ["dynamic-programming", "strings"], points: 20,
    description: "Given two strings, return the length of their longest common subsequence.",
    inputFormat: "Two lines, each a string.", outputFormat: "Length of LCS.",
    constraints: ["1 ≤ text1.length, text2.length ≤ 1000"],
    sampleCases: [{ input: "abcde\nace", output: "3" }],
    testCases: [{ input: "abcde\nace", expectedOutput: "3" }, { input: "abc\nabc", expectedOutput: "3" }, { input: "abc\ndef", expectedOutput: "0" }, { input: "oxcpqrsvwf\nshmtulqrypy", expectedOutput: "2", hidden: true }],
    starterCode: twoLineStarter("LCS"), hints: ["2D DP table."], editorial: "dp[i][j] = LCS of text1[0..i-1] and text2[0..j-1]. O(m×n).",
  },
  {
    id: "number-of-islands", title: "Number of Islands", slug: "number-of-islands", difficulty: "Medium", category: "Graphs",
    tags: ["graphs", "dfs", "bfs"], points: 20,
    description: "Given a 2D grid of '1's (land) and '0's (water), count the number of islands.",
    inputFormat: "First line: rows cols. Following lines: grid rows.", outputFormat: "Number of islands.",
    constraints: ["1 ≤ m, n ≤ 300"],
    sampleCases: [{ input: "4 5\n11110\n11010\n11000\n00000", output: "1" }, { input: "4 5\n11000\n11000\n00100\n00011", output: "3" }],
    testCases: [{ input: "4 5\n11110\n11010\n11000\n00000", expectedOutput: "1" }, { input: "4 5\n11000\n11000\n00100\n00011", expectedOutput: "3" }, { input: "1 1\n1", expectedOutput: "1", hidden: true }],
    starterCode: twoLineStarter("Number of Islands"), hints: ["DFS/BFS from each unvisited '1'."], editorial: "DFS to mark connected land. Count DFS calls. O(m×n).",
  },
  {
    id: "course-schedule", title: "Course Schedule", slug: "course-schedule", difficulty: "Medium", category: "Graphs",
    tags: ["graphs", "topological-sort", "dfs"], points: 20,
    description: "There are `n` courses with prerequisites. Determine if you can finish all courses (no cycle in prerequisite graph).",
    inputFormat: "First line: numCourses. Following: prerequisite pairs (a b = to take a, must take b first).", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ numCourses ≤ 2000"],
    sampleCases: [{ input: "2\n1 0", output: "true" }, { input: "2\n1 0\n0 1", output: "false" }],
    testCases: [{ input: "2\n1 0", expectedOutput: "true" }, { input: "2\n1 0\n0 1", expectedOutput: "false" }, { input: "1", expectedOutput: "true", hidden: true }],
    starterCode: twoLineStarter("Course Schedule"), hints: ["Detect cycle using DFS or BFS topological sort."], editorial: "Topological sort with Kahn's algorithm or DFS cycle detection. O(V+E).",
  },
  {
    id: "binary-tree-level-order", title: "Binary Tree Level Order Traversal", slug: "binary-tree-level-order", difficulty: "Medium", category: "Trees",
    tags: ["trees", "bfs"], points: 20,
    description: "Given a binary tree (level-order, -1=null), return level order traversal as lines.",
    inputFormat: "Space-separated tree values.", outputFormat: "One line per level, space-separated.",
    constraints: ["0 ≤ nodes ≤ 2000"],
    sampleCases: [{ input: "3 9 20 -1 -1 15 7", output: "3\n9 20\n15 7" }],
    testCases: [{ input: "3 9 20 -1 -1 15 7", expectedOutput: "3\n9 20\n15 7" }, { input: "1", expectedOutput: "1" }, { input: "1 2 3 4 5", expectedOutput: "1\n2 3\n4 5", hidden: true }],
    starterCode: arrayStarter("Level Order Traversal"), hints: ["Use BFS with a queue."], editorial: "BFS level by level. O(n).",
  },
  {
    id: "validate-bst", title: "Validate Binary Search Tree", slug: "validate-bst", difficulty: "Medium", category: "Trees",
    tags: ["trees", "dfs", "recursion"], points: 20,
    description: "Given a binary tree (level-order, -1=null), determine if it is a valid BST.",
    inputFormat: "Space-separated integers.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ nodes ≤ 10⁴"],
    sampleCases: [{ input: "2 1 3", output: "true" }, { input: "5 1 4 -1 -1 3 6", output: "false" }],
    testCases: [{ input: "2 1 3", expectedOutput: "true" }, { input: "5 1 4 -1 -1 3 6", expectedOutput: "false" }, { input: "1", expectedOutput: "true", hidden: true }],
    starterCode: arrayStarter("Validate BST"), hints: ["Use min/max bounds during DFS."], editorial: "DFS with (min, max) range for each node. O(n).",
  },
  {
    id: "house-robber", title: "House Robber", slug: "house-robber", difficulty: "Medium", category: "Dynamic Programming",
    tags: ["dynamic-programming"], points: 20,
    description: "Given an array of non-negative integers representing money at each house, find max money you can rob without robbing two adjacent houses.",
    inputFormat: "Space-separated integers.", outputFormat: "Max amount.",
    constraints: ["1 ≤ nums.length ≤ 100"],
    sampleCases: [{ input: "1 2 3 1", output: "4" }, { input: "2 7 9 3 1", output: "12" }],
    testCases: [{ input: "1 2 3 1", expectedOutput: "4" }, { input: "2 7 9 3 1", expectedOutput: "12" }, { input: "2 1 1 2", expectedOutput: "4", hidden: true }],
    starterCode: arrayStarter("House Robber"), hints: ["dp[i] = max(dp[i-1], dp[i-2]+nums[i])"], editorial: "DP: at each house decide to rob or skip. O(n).",
  },
  {
    id: "rotate-image", title: "Rotate Image", slug: "rotate-image", difficulty: "Medium", category: "Arrays",
    tags: ["arrays", "matrix"], points: 20,
    description: "Rotate an n×n matrix 90 degrees clockwise. Print the result row by row.",
    inputFormat: "First line: n. Following n lines: rows.", outputFormat: "Rotated matrix.",
    constraints: ["1 ≤ n ≤ 20"],
    sampleCases: [{ input: "3\n1 2 3\n4 5 6\n7 8 9", output: "7 4 1\n8 5 2\n9 6 3" }],
    testCases: [{ input: "3\n1 2 3\n4 5 6\n7 8 9", expectedOutput: "7 4 1\n8 5 2\n9 6 3" }, { input: "2\n1 2\n3 4", expectedOutput: "3 1\n4 2" }, { input: "1\n1", expectedOutput: "1", hidden: true }],
    starterCode: twoLineStarter("Rotate Image"), hints: ["Transpose then reverse each row."], editorial: "Transpose matrix, then reverse each row. O(n²).",
  },
  {
    id: "subsets", title: "Subsets", slug: "subsets", difficulty: "Medium", category: "Backtracking",
    tags: ["backtracking", "recursion", "bit-manipulation"], points: 20,
    description: "Given an array of unique integers, return all possible subsets. Print each subset as a sorted, space-separated line. Empty set = empty line.",
    inputFormat: "Space-separated integers.", outputFormat: "One subset per line, sorted.",
    constraints: ["1 ≤ nums.length ≤ 10"],
    sampleCases: [{ input: "1 2 3", output: "\n1\n2\n3\n1 2\n1 3\n2 3\n1 2 3" }],
    testCases: [{ input: "1 2 3", expectedOutput: "\n1\n2\n3\n1 2\n1 3\n2 3\n1 2 3" }, { input: "0", expectedOutput: "\n0" }, { input: "1 2", expectedOutput: "\n1\n2\n1 2", hidden: true }],
    starterCode: arrayStarter("Subsets"), hints: ["Use bitmask or recursive backtracking."], editorial: "Backtracking: include or exclude each element. 2^n subsets.",
  },
  {
    id: "permutations", title: "Permutations", slug: "permutations", difficulty: "Medium", category: "Backtracking",
    tags: ["backtracking", "recursion"], points: 20,
    description: "Given an array of distinct integers, return all permutations. Print each on a line.",
    inputFormat: "Space-separated integers.", outputFormat: "One permutation per line.",
    constraints: ["1 ≤ nums.length ≤ 6"],
    sampleCases: [{ input: "1 2 3", output: "1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1" }],
    testCases: [{ input: "1 2 3", expectedOutput: "1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 1 2\n3 2 1" }, { input: "1", expectedOutput: "1" }, { input: "0 1", expectedOutput: "0 1\n1 0", hidden: true }],
    starterCode: arrayStarter("Permutations"), hints: ["Swap elements at each position."], editorial: "Backtracking with swap. n! permutations. O(n × n!).",
  },
  {
    id: "combination-sum", title: "Combination Sum", slug: "combination-sum", difficulty: "Medium", category: "Backtracking",
    tags: ["backtracking", "recursion"], points: 20,
    description: "Given candidates and a target, find all unique combinations that sum to target. Numbers can be used unlimited times.",
    inputFormat: "First line: candidates. Second line: target.", outputFormat: "One combination per line.",
    constraints: ["1 ≤ candidates.length ≤ 30", "2 ≤ candidates[i] ≤ 40", "1 ≤ target ≤ 40"],
    sampleCases: [{ input: "2 3 6 7\n7", output: "2 2 3\n7" }],
    testCases: [{ input: "2 3 6 7\n7", expectedOutput: "2 2 3\n7" }, { input: "2 3 5\n8", expectedOutput: "2 2 2 2\n2 3 3\n3 5" }, { input: "2\n1", expectedOutput: "", hidden: true }],
    starterCode: twoLineStarter("Combination Sum"), hints: ["Backtrack with current sum and start index."], editorial: "Backtracking: try each candidate from current index.",
  },
  {
    id: "word-search", title: "Word Search", slug: "word-search", difficulty: "Medium", category: "Backtracking",
    tags: ["backtracking", "dfs", "matrix"], points: 20,
    description: "Given an m×n grid and a word, return `true` if the word exists in the grid by moving adjacent cells.",
    inputFormat: "First line: m n. Next m lines: grid. Last line: word.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ m, n ≤ 6", "1 ≤ word.length ≤ 15"],
    sampleCases: [{ input: "3 4\nABCE\nSFCS\nADEE\nABCCED", output: "true" }],
    testCases: [{ input: "3 4\nABCE\nSFCS\nADEE\nABCCED", expectedOutput: "true" }, { input: "3 4\nABCE\nSFCS\nADEE\nSEE", expectedOutput: "true" }, { input: "3 4\nABCE\nSFCS\nADEE\nABCB", expectedOutput: "false", hidden: true }],
    starterCode: twoLineStarter("Word Search"), hints: ["DFS from each cell matching first char."], editorial: "DFS with backtracking and visited set. O(m×n×4^L).",
  },
  {
    id: "topological-sort", title: "Topological Sort", slug: "topological-sort", difficulty: "Medium", category: "Graphs",
    tags: ["graphs", "topological-sort"], points: 20,
    description: "Given a DAG with n nodes and edges, print one valid topological ordering.",
    inputFormat: "First line: n m. Next m lines: edges (u v means u→v).", outputFormat: "Space-separated ordering.",
    constraints: ["1 ≤ n ≤ 1000"],
    sampleCases: [{ input: "4 4\n0 1\n0 2\n1 3\n2 3", output: "0 1 2 3" }],
    testCases: [{ input: "4 4\n0 1\n0 2\n1 3\n2 3", expectedOutput: "0 1 2 3" }, { input: "2 1\n1 0", expectedOutput: "1 0" }, { input: "3 0", expectedOutput: "0 1 2", hidden: true }],
    starterCode: twoLineStarter("Topological Sort"), hints: ["Use Kahn's algorithm (BFS with in-degree)."], editorial: "Kahn's: BFS starting from nodes with in-degree 0. O(V+E).",
  },
  {
    id: "dijkstra", title: "Dijkstra's Shortest Path", slug: "dijkstra", difficulty: "Medium", category: "Graphs",
    tags: ["graphs", "greedy", "priority-queue"], points: 20,
    description: "Given a weighted directed graph, find shortest distance from source (node 0) to all other nodes. Print -1 if unreachable.",
    inputFormat: "First line: n m. Next m lines: u v w (edge). ", outputFormat: "Space-separated distances from node 0.",
    constraints: ["1 ≤ n ≤ 1000", "1 ≤ w ≤ 10⁶"],
    sampleCases: [{ input: "4 5\n0 1 1\n0 2 4\n1 2 2\n1 3 6\n2 3 3", output: "0 1 3 6" }],
    testCases: [{ input: "4 5\n0 1 1\n0 2 4\n1 2 2\n1 3 6\n2 3 3", expectedOutput: "0 1 3 6" }, { input: "2 1\n0 1 5", expectedOutput: "0 5" }, { input: "3 1\n0 1 2", expectedOutput: "0 2 -1", hidden: true }],
    starterCode: twoLineStarter("Dijkstra"), hints: ["Use a min-heap / priority queue."], editorial: "Dijkstra's with priority queue. O((V+E)logV).",
  },
  {
    id: "bfs-graph", title: "BFS on Graph", slug: "bfs-graph", difficulty: "Medium", category: "Graphs",
    tags: ["graphs", "bfs"], points: 20,
    description: "Given an undirected graph, perform BFS from node 0 and print the traversal order.",
    inputFormat: "First line: n m. Next m lines: edges (u v).", outputFormat: "Space-separated BFS order.",
    constraints: ["1 ≤ n ≤ 1000"],
    sampleCases: [{ input: "5 6\n0 1\n0 2\n1 3\n2 3\n3 4\n2 4", output: "0 1 2 3 4" }],
    testCases: [{ input: "5 6\n0 1\n0 2\n1 3\n2 3\n3 4\n2 4", expectedOutput: "0 1 2 3 4" }, { input: "3 2\n0 1\n1 2", expectedOutput: "0 1 2" }, { input: "1 0", expectedOutput: "0", hidden: true }],
    starterCode: twoLineStarter("BFS Graph"), hints: ["Use a queue starting from node 0."], editorial: "Standard BFS with visited set. O(V+E).",
  },
  {
    id: "knapsack-01", title: "0/1 Knapsack", slug: "knapsack-01", difficulty: "Medium", category: "Dynamic Programming",
    tags: ["dynamic-programming", "greedy"], points: 20,
    description: "Given n items with weights and values, and a capacity W, find the maximum value achievable.",
    inputFormat: "First line: n W. Next n lines: weight value.", outputFormat: "Max value.",
    constraints: ["1 ≤ n ≤ 100", "1 ≤ W ≤ 1000"],
    sampleCases: [{ input: "3 50\n10 60\n20 100\n30 120", output: "220" }],
    testCases: [{ input: "3 50\n10 60\n20 100\n30 120", expectedOutput: "220" }, { input: "1 1\n2 10", expectedOutput: "0" }, { input: "4 7\n1 1\n3 4\n4 5\n5 7", expectedOutput: "9", hidden: true }],
    starterCode: twoLineStarter("0/1 Knapsack"), hints: ["2D DP: dp[i][w] = max value with first i items and capacity w."], editorial: "dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]]+val[i]). O(nW).",
  },
  {
    id: "longest-increasing-subseq", title: "Longest Increasing Subsequence", slug: "longest-increasing-subsequence", difficulty: "Medium", category: "Dynamic Programming",
    tags: ["dynamic-programming", "binary-search"], points: 20,
    description: "Given an integer array, find the length of the longest strictly increasing subsequence.",
    inputFormat: "Space-separated integers.", outputFormat: "Length of LIS.",
    constraints: ["1 ≤ nums.length ≤ 2500"],
    sampleCases: [{ input: "10 9 2 5 3 7 101 18", output: "4", explanation: "[2,3,7,101]" }],
    testCases: [{ input: "10 9 2 5 3 7 101 18", expectedOutput: "4" }, { input: "0 1 0 3 2 3", expectedOutput: "4" }, { input: "7 7 7 7", expectedOutput: "1", hidden: true }],
    starterCode: arrayStarter("LIS"), hints: ["dp[i] = length of LIS ending at i."], editorial: "DP: dp[i] = max(dp[j]+1) for j<i where nums[j]<nums[i]. O(n²) or O(n log n) with binary search.",
  },

  // ===== HARD (41-55) =====
  {
    id: "median-two-sorted", title: "Median of Two Sorted Arrays", slug: "median-two-sorted", difficulty: "Hard", category: "Arrays",
    tags: ["arrays", "binary-search", "divide-and-conquer"], points: 40,
    description: "Given two sorted arrays, return the median. O(log(m+n)) required.",
    inputFormat: "Two lines of sorted integers.", outputFormat: "Median (one decimal place).",
    constraints: ["0 ≤ m, n ≤ 1000"],
    sampleCases: [{ input: "1 3\n2", output: "2.0" }, { input: "1 2\n3 4", output: "2.5" }],
    testCases: [{ input: "1 3\n2", expectedOutput: "2.0" }, { input: "1 2\n3 4", expectedOutput: "2.5" }, { input: "1 2 3 4 5\n6 7 8 9 10", expectedOutput: "5.5", hidden: true }],
    starterCode: twoLineStarter("Median Two Sorted"), hints: ["Binary search on shorter array."], editorial: "Partition both arrays with binary search. O(log(min(m,n))).",
  },
  {
    id: "lru-cache", title: "LRU Cache", slug: "lru-cache", difficulty: "Hard", category: "Design",
    tags: ["hash-map", "linked-lists", "design"], points: 40,
    description: "Design an LRU Cache with PUT and GET operations.",
    inputFormat: "First line: capacity. Following: PUT key value or GET key.", outputFormat: "Result of each GET.",
    constraints: ["1 ≤ capacity ≤ 3000"],
    sampleCases: [{ input: "2\nPUT 1 1\nPUT 2 2\nGET 1\nPUT 3 3\nGET 2\nPUT 4 4\nGET 1\nGET 3\nGET 4", output: "1\n-1\n-1\n3\n4" }],
    testCases: [{ input: "2\nPUT 1 1\nPUT 2 2\nGET 1\nPUT 3 3\nGET 2\nPUT 4 4\nGET 1\nGET 3\nGET 4", expectedOutput: "1\n-1\n-1\n3\n4" }, { input: "1\nPUT 1 10\nGET 1\nPUT 2 20\nGET 1\nGET 2", expectedOutput: "10\n-1\n20", hidden: true }],
    starterCode: twoLineStarter("LRU Cache"), hints: ["Hash map + doubly linked list."], editorial: "Hash map for O(1) lookup, doubly linked list for recency. O(1) per operation.",
  },
  {
    id: "n-queens", title: "N-Queens", slug: "n-queens", difficulty: "Hard", category: "Backtracking",
    tags: ["backtracking", "recursion"], points: 40,
    description: "Given n, find the number of distinct N-Queens solutions.",
    inputFormat: "A single integer n.", outputFormat: "Number of solutions.",
    constraints: ["1 ≤ n ≤ 9"],
    sampleCases: [{ input: "4", output: "2" }, { input: "1", output: "1" }],
    testCases: [{ input: "4", expectedOutput: "2" }, { input: "1", expectedOutput: "1" }, { input: "8", expectedOutput: "92", hidden: true }],
    starterCode: simpleStarter("N-Queens"), hints: ["Place queens row by row, check column and diagonals."], editorial: "Backtracking with column/diagonal tracking.",
  },
  {
    id: "merge-k-sorted", title: "Merge K Sorted Lists", slug: "merge-k-sorted", difficulty: "Hard", category: "Linked Lists",
    tags: ["linked-lists", "priority-queue", "divide-and-conquer"], points: 40,
    description: "Given k sorted arrays, merge them into one sorted array.",
    inputFormat: "First line: k. Next k lines: sorted arrays.", outputFormat: "Merged sorted array.",
    constraints: ["1 ≤ k ≤ 10⁴"],
    sampleCases: [{ input: "3\n1 4 5\n1 3 4\n2 6", output: "1 1 2 3 4 4 5 6" }],
    testCases: [{ input: "3\n1 4 5\n1 3 4\n2 6", expectedOutput: "1 1 2 3 4 4 5 6" }, { input: "1\n1", expectedOutput: "1" }, { input: "2\n1 3\n2 4", expectedOutput: "1 2 3 4", hidden: true }],
    starterCode: twoLineStarter("Merge K Sorted Lists"), hints: ["Use a min-heap."], editorial: "Priority queue: push heads, pop min, push next. O(N log k).",
  },
  {
    id: "word-ladder", title: "Word Ladder", slug: "word-ladder", difficulty: "Hard", category: "Graphs",
    tags: ["graphs", "bfs"], points: 40,
    description: "Given beginWord, endWord, and a wordList, find the shortest transformation sequence length.",
    inputFormat: "First line: beginWord. Second: endWord. Third: space-separated wordList.", outputFormat: "Length of shortest sequence, or 0.",
    constraints: ["1 ≤ wordList.length ≤ 5000"],
    sampleCases: [{ input: "hit\ncog\nhot dot dog lot log cog", output: "5" }],
    testCases: [{ input: "hit\ncog\nhot dot dog lot log cog", expectedOutput: "5" }, { input: "hit\ncog\nhot dot dog lot log", expectedOutput: "0" }, { input: "a\nc\na b c", expectedOutput: "2", hidden: true }],
    starterCode: twoLineStarter("Word Ladder"), hints: ["BFS where neighbors differ by one char."], editorial: "BFS: each word is a node, edge if differ by 1 char. O(M²×N).",
  },
  {
    id: "trapping-rain-water", title: "Trapping Rain Water", slug: "trapping-rain-water", difficulty: "Hard", category: "Arrays",
    tags: ["arrays", "two-pointers", "stacks", "dynamic-programming"], points: 40,
    description: "Given n non-negative integers representing an elevation map, compute how much water can be trapped.",
    inputFormat: "Space-separated integers.", outputFormat: "Total water trapped.",
    constraints: ["0 ≤ n ≤ 2 × 10⁴", "0 ≤ height[i] ≤ 10⁵"],
    sampleCases: [{ input: "0 1 0 2 1 0 1 3 2 1 2 1", output: "6" }],
    testCases: [{ input: "0 1 0 2 1 0 1 3 2 1 2 1", expectedOutput: "6" }, { input: "4 2 0 3 2 5", expectedOutput: "9" }, { input: "1 0 1", expectedOutput: "1", hidden: true }],
    starterCode: arrayStarter("Trapping Rain Water"), hints: ["Two-pointer approach from both ends."], editorial: "Two pointers: track leftMax/rightMax. O(n) time, O(1) space.",
  },
  {
    id: "edit-distance", title: "Edit Distance", slug: "edit-distance", difficulty: "Hard", category: "Dynamic Programming",
    tags: ["dynamic-programming", "strings"], points: 40,
    description: "Given two strings, find the minimum number of operations (insert, delete, replace) to convert one to the other.",
    inputFormat: "Two lines, each a string.", outputFormat: "Min operations.",
    constraints: ["0 ≤ word.length ≤ 500"],
    sampleCases: [{ input: "horse\nros", output: "3" }, { input: "intention\nexecution", output: "5" }],
    testCases: [{ input: "horse\nros", expectedOutput: "3" }, { input: "intention\nexecution", expectedOutput: "5" }, { input: "\na", expectedOutput: "1", hidden: true }],
    starterCode: twoLineStarter("Edit Distance"), hints: ["2D DP."], editorial: "dp[i][j] = min ops to convert word1[0..i-1] to word2[0..j-1]. O(m×n).",
  },
  {
    id: "serialize-deserialize-bt", title: "Serialize and Deserialize Binary Tree", slug: "serialize-deserialize-bt", difficulty: "Hard", category: "Trees",
    tags: ["trees", "design", "dfs", "bfs"], points: 40,
    description: "Serialize a binary tree to a string and deserialize it back. Given level-order input, output the same after serialize→deserialize.",
    inputFormat: "Space-separated level-order (-1=null).", outputFormat: "Same level-order.",
    constraints: ["0 ≤ nodes ≤ 10⁴"],
    sampleCases: [{ input: "1 2 3 -1 -1 4 5", output: "1 2 3 -1 -1 4 5" }],
    testCases: [{ input: "1 2 3 -1 -1 4 5", expectedOutput: "1 2 3 -1 -1 4 5" }, { input: "1", expectedOutput: "1" }, { input: "1 2 -1 3", expectedOutput: "1 2 -1 3", hidden: true }],
    starterCode: arrayStarter("Serialize/Deserialize BT"), hints: ["Use preorder with null markers."], editorial: "Preorder DFS with null markers. O(n).",
  },
  {
    id: "lowest-common-ancestor", title: "Lowest Common Ancestor of BST", slug: "lowest-common-ancestor", difficulty: "Hard", category: "Trees",
    tags: ["trees", "recursion", "bfs"], points: 40,
    description: "Given a BST (level-order) and two node values p and q, find their LCA value.",
    inputFormat: "First line: tree. Second line: p q.", outputFormat: "LCA value.",
    constraints: ["2 ≤ nodes ≤ 10⁵"],
    sampleCases: [{ input: "6 2 8 0 4 7 9 -1 -1 3 5\n2 8", output: "6" }],
    testCases: [{ input: "6 2 8 0 4 7 9 -1 -1 3 5\n2 8", expectedOutput: "6" }, { input: "6 2 8 0 4 7 9 -1 -1 3 5\n2 4", expectedOutput: "2" }, { input: "2 1 3\n1 3", expectedOutput: "2", hidden: true }],
    starterCode: twoLineStarter("LCA of BST"), hints: ["If both < root, go left. Both > root, go right. Otherwise root is LCA."], editorial: "Use BST property to decide direction. O(h).",
  },
  {
    id: "graph-coloring", title: "Graph Coloring", slug: "graph-coloring", difficulty: "Hard", category: "Graphs",
    tags: ["graphs", "backtracking"], points: 40,
    description: "Given a graph and m colors, determine if the graph can be colored with at most m colors such that no two adjacent nodes share a color.",
    inputFormat: "First line: n m. Next lines: edges.", outputFormat: "`true` or `false`",
    constraints: ["1 ≤ n ≤ 20"],
    sampleCases: [{ input: "4 3\n0 1\n0 2\n1 2\n2 3", output: "true" }],
    testCases: [{ input: "4 3\n0 1\n0 2\n1 2\n2 3", expectedOutput: "true" }, { input: "3 2\n0 1\n1 2\n0 2", expectedOutput: "false" }, { input: "4 2\n0 1\n2 3", expectedOutput: "true", hidden: true }],
    starterCode: twoLineStarter("Graph Coloring"), hints: ["Backtracking: try each color for each node."], editorial: "Backtracking with constraint checking. O(m^n) worst case.",
  },
  {
    id: "sudoku-solver", title: "Sudoku Solver", slug: "sudoku-solver", difficulty: "Hard", category: "Backtracking",
    tags: ["backtracking", "recursion", "matrix"], points: 40,
    description: "Solve a Sudoku puzzle. 0 represents empty cells.",
    inputFormat: "9 lines of 9 space-separated digits.", outputFormat: "Solved 9×9 grid.",
    constraints: ["Valid Sudoku input with unique solution."],
    sampleCases: [{ input: "5 3 0 0 7 0 0 0 0\n6 0 0 1 9 5 0 0 0\n0 9 8 0 0 0 0 6 0\n8 0 0 0 6 0 0 0 3\n4 0 0 8 0 3 0 0 1\n7 0 0 0 2 0 0 0 6\n0 6 0 0 0 0 2 8 0\n0 0 0 4 1 9 0 0 5\n0 0 0 0 8 0 0 7 9", output: "5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9" }],
    testCases: [{ input: "5 3 0 0 7 0 0 0 0\n6 0 0 1 9 5 0 0 0\n0 9 8 0 0 0 0 6 0\n8 0 0 0 6 0 0 0 3\n4 0 0 8 0 3 0 0 1\n7 0 0 0 2 0 0 0 6\n0 6 0 0 0 0 2 8 0\n0 0 0 4 1 9 0 0 5\n0 0 0 0 8 0 0 7 9", expectedOutput: "5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9" }],
    starterCode: twoLineStarter("Sudoku Solver"), hints: ["Try each number 1-9 in empty cells, backtrack on conflict."], editorial: "Backtracking with row/col/box constraint checking.",
  },
  {
    id: "matrix-chain-mult", title: "Matrix Chain Multiplication", slug: "matrix-chain-multiplication", difficulty: "Hard", category: "Dynamic Programming",
    tags: ["dynamic-programming"], points: 40,
    description: "Given dimensions of matrices, find the minimum number of scalar multiplications needed.",
    inputFormat: "Space-separated dimensions array p (n+1 values for n matrices).", outputFormat: "Min multiplications.",
    constraints: ["2 ≤ p.length ≤ 100"],
    sampleCases: [{ input: "10 20 30 40 30", output: "30000" }],
    testCases: [{ input: "10 20 30 40 30", expectedOutput: "30000" }, { input: "40 20 30 10 30", expectedOutput: "26000" }, { input: "10 20 30", expectedOutput: "6000", hidden: true }],
    starterCode: arrayStarter("Matrix Chain Multiplication"), hints: ["Interval DP: dp[i][j] = min cost of multiplying matrices i to j."], editorial: "dp[i][j] = min(dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j]). O(n³).",
  },
  {
    id: "kruskal-mst", title: "Kruskal's MST", slug: "kruskal-mst", difficulty: "Hard", category: "Graphs",
    tags: ["graphs", "greedy", "union-find"], points: 40,
    description: "Given a weighted undirected graph, find the total weight of the Minimum Spanning Tree using Kruskal's algorithm.",
    inputFormat: "First line: n m. Next m lines: u v w.", outputFormat: "Total MST weight.",
    constraints: ["1 ≤ n ≤ 1000"],
    sampleCases: [{ input: "4 5\n0 1 10\n0 2 6\n0 3 5\n1 3 15\n2 3 4", output: "19" }],
    testCases: [{ input: "4 5\n0 1 10\n0 2 6\n0 3 5\n1 3 15\n2 3 4", expectedOutput: "19" }, { input: "3 3\n0 1 1\n1 2 2\n0 2 3", expectedOutput: "3" }, { input: "2 1\n0 1 7", expectedOutput: "7", hidden: true }],
    starterCode: twoLineStarter("Kruskal's MST"), hints: ["Sort edges by weight, use Union-Find."], editorial: "Sort edges, use Union-Find to avoid cycles. O(E log E).",
  },
  {
    id: "longest-path-dag", title: "Longest Path in DAG", slug: "longest-path-dag", difficulty: "Hard", category: "Graphs",
    tags: ["graphs", "dynamic-programming", "topological-sort"], points: 40,
    description: "Given a weighted DAG, find the longest path from source node 0.",
    inputFormat: "First line: n m. Next m lines: u v w.", outputFormat: "Space-separated longest distances (-1 if unreachable).",
    constraints: ["1 ≤ n ≤ 1000"],
    sampleCases: [{ input: "4 4\n0 1 2\n0 2 3\n1 3 6\n2 3 4", output: "0 2 3 8" }],
    testCases: [{ input: "4 4\n0 1 2\n0 2 3\n1 3 6\n2 3 4", expectedOutput: "0 2 3 8" }, { input: "2 1\n0 1 5", expectedOutput: "0 5" }, { input: "3 1\n0 1 3", expectedOutput: "0 3 -1", hidden: true }],
    starterCode: twoLineStarter("Longest Path in DAG"), hints: ["Use topological sort then relax edges."], editorial: "Topological sort, then relax edges in order. O(V+E).",
  },
  {
    id: "activity-selection", title: "Activity Selection (Greedy)", slug: "activity-selection", difficulty: "Hard", category: "Greedy",
    tags: ["greedy", "sorting"], points: 40,
    description: "Given n activities with start and end times, find the maximum number of non-overlapping activities.",
    inputFormat: "First line: n. Next n lines: start end.", outputFormat: "Max activities.",
    constraints: ["1 ≤ n ≤ 10⁵"],
    sampleCases: [{ input: "6\n1 2\n3 4\n0 6\n5 7\n8 9\n5 9", output: "4" }],
    testCases: [{ input: "6\n1 2\n3 4\n0 6\n5 7\n8 9\n5 9", expectedOutput: "4" }, { input: "1\n0 1", expectedOutput: "1" }, { input: "3\n1 3\n2 4\n3 5", expectedOutput: "2", hidden: true }],
    starterCode: twoLineStarter("Activity Selection"), hints: ["Sort by end time, greedily pick."], editorial: "Sort by end time. Pick activity if start >= last end. O(n log n).",
  },
];

// Derive tags and categories
export const allTags = Array.from(new Set(codingProblems.flatMap((p) => p.tags))).sort();
export const allCategories = Array.from(new Set(codingProblems.map((p) => p.category))).sort();

export const codingCourses: CodingCourse[] = [
  { id: "c-basics", title: "C Programming", description: "Master fundamentals of C", icon: "🔧", problemIds: ["fizzbuzz", "reverse-string", "counting-sort", "binary-search", "merge-sorted-arrays", "move-zeroes"] },
  { id: "dsa-fundamentals", title: "Data Structures", description: "Arrays, stacks, linked lists, trees", icon: "🏗️", problemIds: ["two-sum", "valid-parentheses", "linked-list-reverse", "linked-list-cycle", "max-depth-bt", "invert-binary-tree", "symmetric-tree", "lru-cache"] },
  { id: "java-problems", title: "Java Challenges", description: "Practice Java with classic problems", icon: "☕", problemIds: ["palindrome-check", "valid-anagram", "contains-duplicate", "sort-array", "rotate-image", "binary-tree-level-order"] },
  { id: "python-dsa", title: "Python DSA", description: "Solve DSA problems in Python", icon: "🐍", problemIds: ["climbing-stairs", "max-subarray", "house-robber", "coin-change", "longest-common-subseq", "longest-increasing-subseq", "knapsack-01"] },
  { id: "graphs-advanced", title: "Graphs & Advanced", description: "Graph algorithms and advanced topics", icon: "🌐", problemIds: ["number-of-islands", "course-schedule", "bfs-graph", "topological-sort", "dijkstra", "word-ladder", "kruskal-mst", "longest-path-dag"] },
  { id: "backtracking-mastery", title: "Backtracking Mastery", description: "Master recursive backtracking", icon: "🔄", problemIds: ["subsets", "permutations", "combination-sum", "word-search", "n-queens", "sudoku-solver", "graph-coloring"] },
  { id: "dp-track", title: "Dynamic Programming", description: "From basics to advanced DP", icon: "📊", problemIds: ["climbing-stairs", "house-robber", "coin-change", "longest-common-subseq", "longest-increasing-subseq", "knapsack-01", "edit-distance", "matrix-chain-mult"] },
  { id: "greedy-track", title: "Greedy Algorithms", description: "Greedy strategy problems", icon: "💰", problemIds: ["best-time-buy-sell", "activity-selection", "max-subarray"] },
];

export const POINTS_MAP: Record<string, number> = { Easy: 10, Medium: 20, Hard: 40 };
